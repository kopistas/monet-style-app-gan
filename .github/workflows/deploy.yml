name: Deploy Infrastructure and Applications

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  DOCKER_REGISTRY: ghcr.io/${{ github.repository_owner }}
  TF_VERSION: "1.5.7"

jobs:
  terraform:
    name: Terraform
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        working-directory: terraform
        env:
          DO_TOKEN: ${{ secrets.DO_TOKEN }}
          DO_SPACES_ACCESS_KEY: ${{ secrets.DO_SPACES_ACCESS_KEY }}
          DO_SPACES_SECRET_KEY: ${{ secrets.DO_SPACES_SECRET_KEY }}
          TF_VAR_do_token: ${{ secrets.DO_TOKEN }}
          AWS_ACCESS_KEY_ID: ${{ secrets.DO_SPACES_ACCESS_KEY }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.DO_SPACES_SECRET_KEY }}
        run: |
          terraform init -backend-config="access_key=$DO_SPACES_ACCESS_KEY" -backend-config="secret_key=$DO_SPACES_SECRET_KEY"

      - name: Terraform Plan
        working-directory: terraform
        env:
          DO_TOKEN: ${{ secrets.DO_TOKEN }}
          TF_VAR_do_token: ${{ secrets.DO_TOKEN }}
          TF_VAR_do_region: ${{ secrets.DO_REGION || 'nyc1' }}
          TF_VAR_do_spaces_region: ${{ secrets.DO_SPACES_REGION || 'nyc3' }}
          TF_VAR_do_spaces_name: ${{ secrets.DO_SPACES_NAME || 'monet-models' }}
          TF_VAR_do_spaces_access_key: ${{ secrets.DO_SPACES_ACCESS_KEY }}
          TF_VAR_do_spaces_secret_key: ${{ secrets.DO_SPACES_SECRET_KEY }}
          TF_VAR_app_domain: ${{ secrets.APP_DOMAIN || 'monet-app.example.com' }}
          TF_VAR_mlflow_domain: ${{ secrets.MLFLOW_DOMAIN || 'mlflow.example.com' }}
          TF_VAR_unsplash_api_key: ${{ secrets.UNSPLASH_API_KEY || '' }}
          TF_VAR_email_for_ssl: ${{ secrets.EMAIL_FOR_SSL || 'admin@example.com' }}
          TF_VAR_use_do_dns: ${{ secrets.USE_DO_DNS || 'false' }}
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        working-directory: terraform
        env:
          DO_TOKEN: ${{ secrets.DO_TOKEN }}
          TF_VAR_do_token: ${{ secrets.DO_TOKEN }}
          TF_VAR_do_spaces_access_key: ${{ secrets.DO_SPACES_ACCESS_KEY }}
          TF_VAR_do_spaces_secret_key: ${{ secrets.DO_SPACES_SECRET_KEY }}
          TF_VAR_do_region: ${{ secrets.DO_REGION || 'nyc1' }}
          TF_VAR_do_spaces_region: ${{ secrets.DO_SPACES_REGION || 'nyc3' }}
          TF_VAR_app_domain: ${{ secrets.APP_DOMAIN }}
          TF_VAR_mlflow_domain: ${{ secrets.MLFLOW_DOMAIN }}
        run: terraform apply -auto-approve tfplan

      - name: Save Terraform Output
        working-directory: terraform
        run: |
          mkdir -p ../kubernetes/output
          # Save raw output to a file
          terraform output -json > ../kubernetes/output/terraform-output-raw.json
          
          # Extract only the valid JSON part from the file
          echo "Cleaning Terraform output file..."
          # Look for the start of a JSON object and extract until the end of the JSON
          sed -n '/^{/,/^}$/p' ../kubernetes/output/terraform-output-raw.json > ../kubernetes/output/terraform-output.json
          
          # If that didn't work, try extracting everything between the first { and last }
          if ! jq empty ../kubernetes/output/terraform-output.json 2>/dev/null; then
            echo "Using alternative extraction method..."
            # Use awk to extract everything between first { and last }
            awk 'BEGIN{flag=0} /^{/{flag=1} flag{print} /^}$/{flag=0}' ../kubernetes/output/terraform-output-raw.json > ../kubernetes/output/terraform-output.json
          fi
          
          # If still not valid, try manual regeneration
          if ! jq empty ../kubernetes/output/terraform-output.json 2>/dev/null; then
            echo "Manual JSON extraction failed. Creating clean JSON..."
            # Manually create a clean JSON file with the required values
            echo "{" > ../kubernetes/output/terraform-output.json
            terraform output -raw spaces_region 2>/dev/null | xargs -I{} echo "  \"spaces_region\": { \"value\": \"{}\" }," >> ../kubernetes/output/terraform-output.json
            terraform output -raw spaces_bucket_name 2>/dev/null | xargs -I{} echo "  \"spaces_bucket_name\": { \"value\": \"{}\" }," >> ../kubernetes/output/terraform-output.json
            terraform output -raw dns_configuration 2>/dev/null | xargs -I{} echo "  \"dns_configuration\": { \"value\": \"{}\" }" >> ../kubernetes/output/terraform-output.json
            echo "}" >> ../kubernetes/output/terraform-output.json
          fi
          
          # Show final file contents
          echo "Final Terraform output file contents:"
          cat ../kubernetes/output/terraform-output.json

      - name: Upload Kubernetes Config
        uses: actions/upload-artifact@v4
        with:
          name: kubeconfig
          path: terraform/kubeconfig.yaml
          retention-days: 1

      - name: Upload Terraform Output
        uses: actions/upload-artifact@v4
        with:
          name: terraform-output
          path: kubernetes/output/terraform-output.json
          retention-days: 1

  build-web-app:
    name: Build Web App
    runs-on: ubuntu-latest
    needs: terraform
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build and push Docker image
        uses: docker/build-push-action@v3
        with:
          context: .
          file: kubernetes/web-app/Dockerfile
          push: true
          tags: ${{ env.DOCKER_REGISTRY }}/monet-web-app:${{ github.sha }},${{ env.DOCKER_REGISTRY }}/monet-web-app:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: Deploy Applications
    runs-on: ubuntu-latest
    needs: [terraform, build-web-app]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Download Kubeconfig
        uses: actions/download-artifact@v4
        with:
          name: kubeconfig
          path: .kube

      - name: Download Terraform Output
        uses: actions/download-artifact@v4
        with:
          name: terraform-output
          path: kubernetes/output

      - name: Set up Kubernetes CLI
        uses: azure/setup-kubectl@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Export Environment Variables
        run: |
          # Check if output file exists
          echo "Validating Terraform output file..."
          if [ ! -f kubernetes/output/terraform-output.json ]; then
            echo "ERROR: Terraform output file not found. Terraform step likely failed."
            exit 1
          fi
          
          # Display file contents for debugging
          echo "Terraform output file contents:"
          cat kubernetes/output/terraform-output.json
          
          # If file exists but isn't valid JSON, try direct extraction of values
          if ! jq empty kubernetes/output/terraform-output.json 2>/dev/null; then
            echo "ERROR: Terraform output file is not valid JSON. Attempting direct extraction..."
            
            # Create a new clean file using grep to find the values
            echo "Creating clean JSON with extracted values..."
            echo "{" > kubernetes/output/terraform-output-clean.json
            
            # Extract spaces_region
            REGION_LINE=$(grep -A 3 "spaces_region" kubernetes/output/terraform-output.json | grep "value" | head -1)
            if [[ $REGION_LINE =~ \"value\":[[:space:]]*\"([^\"]+)\" ]]; then
              REGION="${BASH_REMATCH[1]}"
              echo "  \"spaces_region\": { \"value\": \"$REGION\" }," >> kubernetes/output/terraform-output-clean.json
            else
              echo "ERROR: Could not extract spaces_region value"
              exit 1
            fi
            
            # Extract spaces_bucket_name
            BUCKET_LINE=$(grep -A 3 "spaces_bucket_name" kubernetes/output/terraform-output.json | grep "value" | head -1)
            if [[ $BUCKET_LINE =~ \"value\":[[:space:]]*\"([^\"]+)\" ]]; then
              BUCKET="${BASH_REMATCH[1]}"
              echo "  \"spaces_bucket_name\": { \"value\": \"$BUCKET\" }," >> kubernetes/output/terraform-output-clean.json
            else
              echo "ERROR: Could not extract spaces_bucket_name value"
              exit 1
            fi
            
            # Extract dns_configuration
            DNS_LINE=$(grep -A 3 "dns_configuration" kubernetes/output/terraform-output.json | grep "value" | head -1)
            if [[ $DNS_LINE =~ \"value\":[[:space:]]*\"([^\"]+)\" ]]; then
              DNS="${BASH_REMATCH[1]}"
              echo "  \"dns_configuration\": { \"value\": \"$DNS\" }" >> kubernetes/output/terraform-output-clean.json
            else
              echo "No dns_configuration found, adding empty value"
              echo "  \"dns_configuration\": { \"value\": \"\" }" >> kubernetes/output/terraform-output-clean.json
            fi
            
            echo "}" >> kubernetes/output/terraform-output-clean.json
            
            # Replace the original file with the clean one
            mv kubernetes/output/terraform-output-clean.json kubernetes/output/terraform-output.json
            
            echo "Clean JSON file created:"
            cat kubernetes/output/terraform-output.json
          fi
          
          # Extract required values, fail if any are missing
          echo "Extracting values..."
          
          # Extract each value individually with detailed error checking
          DO_SPACES_REGION=$(jq -r '.spaces_region.value // empty' kubernetes/output/terraform-output.json)
          echo "Extracted DO_SPACES_REGION: '$DO_SPACES_REGION'"
          
          DO_SPACES_NAME=$(jq -r '.spaces_bucket_name.value // empty' kubernetes/output/terraform-output.json)
          echo "Extracted DO_SPACES_NAME: '$DO_SPACES_NAME'"
          
          DNS_CONFIG=$(jq -r '.dns_configuration.value // empty' kubernetes/output/terraform-output.json)
          echo "Extracted DNS_CONFIG: '$DNS_CONFIG'"
          
          # Fail if critical values are missing
          if [ -z "$DO_SPACES_REGION" ]; then
            echo "ERROR: spaces_region.value not found or empty in Terraform output"
            exit 1
          fi
          
          if [ -z "$DO_SPACES_NAME" ]; then
            echo "ERROR: spaces_bucket_name.value not found or empty in Terraform output"
            exit 1
          fi
          
          # Set environment variables
          echo "DO_SPACES_REGION=$DO_SPACES_REGION" >> $GITHUB_ENV
          echo "DO_SPACES_NAME=$DO_SPACES_NAME" >> $GITHUB_ENV
          echo "BACKEND_STORE_URI=file:///mlflow-db/mlflow.db" >> $GITHUB_ENV
          echo "DOCKER_REGISTRY=${DOCKER_REGISTRY}" >> $GITHUB_ENV
          echo "IMAGE_TAG=${{ github.sha }}" >> $GITHUB_ENV
          echo "APP_DOMAIN=${{ secrets.APP_DOMAIN }}" >> $GITHUB_ENV
          echo "MLFLOW_DOMAIN=${{ secrets.MLFLOW_DOMAIN }}" >> $GITHUB_ENV
          echo "EMAIL_FOR_SSL=${{ secrets.EMAIL_FOR_SSL || 'admin@example.com' }}" >> $GITHUB_ENV
          echo "UNSPLASH_API_KEY_BASE64=$(echo -n '${{ secrets.UNSPLASH_API_KEY || '' }}' | base64)" >> $GITHUB_ENV
          echo "DO_SPACES_ACCESS_KEY_BASE64=$(echo -n '${{ secrets.DO_SPACES_ACCESS_KEY }}' | base64)" >> $GITHUB_ENV
          echo "DO_SPACES_SECRET_KEY_BASE64=$(echo -n '${{ secrets.DO_SPACES_SECRET_KEY }}' | base64)" >> $GITHUB_ENV
          
          # Set DNS configuration 
          if [ -z "$DNS_CONFIG" ]; then
            echo "WARNING: dns_configuration.value not found or empty in Terraform output"
            echo "DNS_CONFIG=Missing in Terraform output" >> $GITHUB_ENV
          else
            echo "DNS_CONFIG=$DNS_CONFIG" >> $GITHUB_ENV
          fi

      - name: Display Environment Variables
        run: |
          echo "DO_SPACES_REGION: $DO_SPACES_REGION"
          echo "DO_SPACES_NAME: $DO_SPACES_NAME"
          echo "BACKEND_STORE_URI: $BACKEND_STORE_URI"
          echo "S3 ENDPOINT would be: https://$DO_SPACES_REGION.digitaloceanspaces.com"
          echo "DNS Configuration: $DNS_CONFIG"

      - name: Apply Kubernetes Manifests - Cert Manager
        run: |
          export KUBECONFIG=${{ github.workspace }}/.kube/kubeconfig.yaml
          
          # Apply cert-manager issuer
          envsubst < kubernetes/cert-manager/issuer.yaml | kubectl apply -f -

      - name: Apply Kubernetes Manifests - MLflow
        run: |
          # MLflow deployment commented out to prevent public exposure
          echo "Skipping MLflow deployment for security reasons"
          
          # Instead, actively remove any existing MLflow resources
          export KUBECONFIG=${{ github.workspace }}/.kube/kubeconfig.yaml
          echo "Removing existing MLflow deployment..."
          
          # Delete MLflow ingress
          kubectl delete ingress -n mlflow mlflow --ignore-not-found=true
          
          # Delete MLflow service
          kubectl delete service -n mlflow mlflow --ignore-not-found=true
          
          # Delete MLflow deployment
          kubectl delete deployment -n mlflow mlflow --ignore-not-found=true
          
          # Keep the namespace and PVC for future use, but don't deploy MLflow
          echo "MLflow resources have been removed for security"
          
          # The following lines are commented out to prevent MLflow exposure:
          # # Apply MLflow manifests
          # envsubst < kubernetes/mlflow/deployment.yaml | kubectl apply -f -
          # 
          # # Wait for MLflow PVC to be bound (give it up to 2 minutes)
          # echo "Waiting for MLflow PVC to be provisioned..."
          # kubectl wait --for=condition=Ready pvc/mlflow-database -n mlflow --timeout=120s || true
          # 
          # # Force rollout of MLflow deployment to apply changes
          # kubectl rollout restart deployment/mlflow -n mlflow
          # 
          # # Wait for initial pod creation but don't fail pipeline if it's not ready yet
          # echo "Waiting for initial MLflow pod creation..."
          # kubectl rollout status deployment/mlflow -n mlflow --timeout=30s || true

      - name: Apply Kubernetes Manifests - Web App
        run: |
          export KUBECONFIG=${{ github.workspace }}/.kube/kubeconfig.yaml
          
          # Apply namespace first
          envsubst < kubernetes/web-app/namespace.yaml | kubectl apply -f -
          
          # Apply storage resources
          envsubst < kubernetes/web-app/storage.yaml | kubectl apply -f -
          
          # Apply secrets and configmaps
          envsubst < kubernetes/web-app/spaces-secret.yaml | kubectl apply -f -
          
          # Apply Web App manifests
          envsubst < kubernetes/web-app/deployment.yaml | kubectl apply -f -
          
          # Force rollout of web app deployment to apply changes
          kubectl rollout restart deployment/monet-web-app -n monet-app
          
          # Wait for initial pod creation but don't fail pipeline if it's not ready yet
          echo "Waiting for initial web app pod creation..."
          kubectl rollout status deployment/monet-web-app -n monet-app --timeout=30s || true

      - name: Upload Model to S3
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.DO_SPACES_ACCESS_KEY }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.DO_SPACES_SECRET_KEY }}
          AWS_REGION: ${{ secrets.DO_SPACES_REGION }}
          S3_ENDPOINT: "https://${{ secrets.DO_SPACES_REGION }}.digitaloceanspaces.com"
          BUCKET_NAME: ${{ secrets.DO_SPACES_NAME }}
        run: |
          pip install boto3 mlflow
          
          echo "Using S3 endpoint: $S3_ENDPOINT"
          echo "Using bucket name: $BUCKET_NAME"
          
          # Use the model promotion script to upload and mark as production
          python scripts/promote_model.py photo2monet_cyclegan_mark4.pt \
            --bucket $BUCKET_NAME \
            --version "$(date +%Y%m%d%H%M%S)" \
            --model-name "monet-style-transfer"

      - name: Wait and Verify Deployment
        timeout-minutes: 15
        run: |
          echo "Waiting for services to initialize..."
          sleep 60
          
          echo "Installing required packages for verification..."
          pip install requests urllib3
          
          echo "Running deployment verification..."
          export KUBECONFIG=${{ github.workspace }}/.kube/kubeconfig.yaml
          # Only verify monet-app namespace since MLflow is disabled
          python scripts/verify_deployment.py --timeout 600 --skip-wait --namespaces monet-app
          
          echo "Verification complete!"
          
          echo "You can access the application at:"
          echo "- Monet App: https://${{ env.APP_DOMAIN }}" 