name: Deploy Infrastructure and Applications

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  DOCKER_REGISTRY: ghcr.io/${{ github.repository_owner }}
  TF_VERSION: "1.5.7"

jobs:
  terraform:
    name: Terraform
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        working-directory: terraform
        env:
          DO_TOKEN: ${{ secrets.DO_TOKEN }}
          DO_SPACES_ACCESS_KEY: ${{ secrets.DO_SPACES_ACCESS_KEY }}
          DO_SPACES_SECRET_KEY: ${{ secrets.DO_SPACES_SECRET_KEY }}
          TF_VAR_do_token: ${{ secrets.DO_TOKEN }}
          AWS_ACCESS_KEY_ID: ${{ secrets.DO_SPACES_ACCESS_KEY }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.DO_SPACES_SECRET_KEY }}
        run: |
          terraform init -backend-config="access_key=$DO_SPACES_ACCESS_KEY" -backend-config="secret_key=$DO_SPACES_SECRET_KEY"

      - name: Terraform Plan
        working-directory: terraform
        env:
          DO_TOKEN: ${{ secrets.DO_TOKEN }}
          TF_VAR_do_token: ${{ secrets.DO_TOKEN }}
          TF_VAR_do_region: ${{ secrets.DO_REGION || 'nyc1' }}
          TF_VAR_do_spaces_region: ${{ secrets.DO_SPACES_REGION || 'nyc3' }}
          TF_VAR_do_spaces_name: ${{ secrets.DO_SPACES_NAME || 'monet-models' }}
          TF_VAR_do_spaces_access_key: ${{ secrets.DO_SPACES_ACCESS_KEY }}
          TF_VAR_do_spaces_secret_key: ${{ secrets.DO_SPACES_SECRET_KEY }}
          TF_VAR_app_domain: ${{ secrets.APP_DOMAIN || 'monet-app.example.com' }}
          TF_VAR_mlflow_domain: ${{ secrets.MLFLOW_DOMAIN || 'mlflow.example.com' }}
          TF_VAR_unsplash_api_key: ${{ secrets.UNSPLASH_API_KEY || '' }}
          TF_VAR_email_for_ssl: ${{ secrets.EMAIL_FOR_SSL || 'admin@example.com' }}
          TF_VAR_use_do_dns: ${{ secrets.USE_DO_DNS || 'false' }}
          TF_VAR_deploy_mlflow: ${{ secrets.DEPLOY_MLFLOW || 'false' }}
          TF_VAR_load_balancer_ip: ${{ secrets.LOAD_BALANCER_IP || '' }}
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        working-directory: terraform
        env:
          DO_TOKEN: ${{ secrets.DO_TOKEN }}
          TF_VAR_do_token: ${{ secrets.DO_TOKEN }}
          TF_VAR_do_spaces_access_key: ${{ secrets.DO_SPACES_ACCESS_KEY }}
          TF_VAR_do_spaces_secret_key: ${{ secrets.DO_SPACES_SECRET_KEY }}
          TF_VAR_do_region: ${{ secrets.DO_REGION || 'nyc1' }}
          TF_VAR_do_spaces_region: ${{ secrets.DO_SPACES_REGION || 'nyc3' }}
          TF_VAR_app_domain: ${{ secrets.APP_DOMAIN }}
          TF_VAR_mlflow_domain: ${{ secrets.MLFLOW_DOMAIN }}
          TF_VAR_deploy_mlflow: ${{ secrets.DEPLOY_MLFLOW || 'false' }}
          TF_VAR_load_balancer_ip: ${{ secrets.LOAD_BALANCER_IP || '' }}
        run: terraform apply -auto-approve tfplan

      - name: Save Terraform Output and Update for Next Run
        working-directory: terraform
        run: |
          mkdir -p ../kubernetes/output
          
          # Add the load balancer IP to env vars for next terraform run
          if [ -n "$LOAD_BALANCER_IP" ]; then
            echo "TF_VAR_load_balancer_ip=$LOAD_BALANCER_IP" >> $GITHUB_ENV
          fi
          
          # Save raw output to a file
          terraform output -json > ../kubernetes/output/terraform-output-raw.json
          
          # Extract only the valid JSON part from the file
          echo "Cleaning Terraform output file..."
          # Look for the start of a JSON object and extract until the end of the JSON
          sed -n '/^{/,/^}$/p' ../kubernetes/output/terraform-output-raw.json > ../kubernetes/output/terraform-output.json
          
          # If that didn't work, try extracting everything between the first { and last }
          if ! jq empty ../kubernetes/output/terraform-output.json 2>/dev/null; then
            echo "Using alternative extraction method..."
            # Use awk to extract everything between first { and last }
            awk 'BEGIN{flag=0} /^{/{flag=1} flag{print} /^}$/{flag=0}' ../kubernetes/output/terraform-output-raw.json > ../kubernetes/output/terraform-output.json
          fi
          
          # If still not valid, try manual regeneration
          if ! jq empty ../kubernetes/output/terraform-output.json 2>/dev/null; then
            echo "Manual JSON extraction failed. Creating clean JSON..."
            # Manually create a clean JSON file with the required values
            echo "{" > ../kubernetes/output/terraform-output.json
            terraform output -raw spaces_region 2>/dev/null | xargs -I{} echo "  \"spaces_region\": { \"value\": \"{}\" }," >> ../kubernetes/output/terraform-output.json
            terraform output -raw spaces_bucket_name 2>/dev/null | xargs -I{} echo "  \"spaces_bucket_name\": { \"value\": \"{}\" }," >> ../kubernetes/output/terraform-output.json
            terraform output -raw dns_configuration 2>/dev/null | xargs -I{} echo "  \"dns_configuration\": { \"value\": \"{}\" }," >> ../kubernetes/output/terraform-output.json
            # Use load_balancer_ip from environment if available, otherwise empty
            if [ -n "$LOAD_BALANCER_IP" ]; then
              echo "  \"load_balancer_ip\": { \"value\": \"$LOAD_BALANCER_IP\" }" >> ../kubernetes/output/terraform-output.json
            else
              echo "  \"load_balancer_ip\": { \"value\": \"\" }" >> ../kubernetes/output/terraform-output.json
            fi
            echo "}" >> ../kubernetes/output/terraform-output.json
          fi
          
          # Show final file contents
          echo "Final Terraform output file contents:"
          cat ../kubernetes/output/terraform-output.json

      - name: Upload Kubernetes Config
        uses: actions/upload-artifact@v4
        with:
          name: kubeconfig
          path: terraform/kubeconfig.yaml
          retention-days: 1

      - name: Upload Terraform Output
        uses: actions/upload-artifact@v4
        with:
          name: terraform-output
          path: kubernetes/output/terraform-output.json
          retention-days: 1

  build-web-app:
    name: Build Web App
    runs-on: ubuntu-latest
    needs: terraform
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build and push Docker image
        uses: docker/build-push-action@v3
        with:
          context: .
          file: kubernetes/web-app/Dockerfile
          push: true
          tags: ${{ env.DOCKER_REGISTRY }}/monet-web-app:${{ github.sha }},${{ env.DOCKER_REGISTRY }}/monet-web-app:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: Deploy Applications
    runs-on: ubuntu-latest
    needs: [terraform, build-web-app]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Download Kubeconfig
        uses: actions/download-artifact@v4
        with:
          name: kubeconfig
          path: .kube

      - name: Download Terraform Output
        uses: actions/download-artifact@v4
        with:
          name: terraform-output
          path: kubernetes/output

      - name: Set up Kubernetes CLI
        uses: azure/setup-kubectl@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Export Environment Variables
        run: |
          # Check if output file exists
          echo "Validating Terraform output file..."
          if [ ! -f kubernetes/output/terraform-output.json ]; then
            echo "ERROR: Terraform output file not found. Terraform step likely failed."
            exit 1
          fi
          
          # Display file contents for debugging
          echo "Terraform output file contents:"
          cat kubernetes/output/terraform-output.json
          
          # If file exists but isn't valid JSON, try direct extraction of values
          if ! jq empty kubernetes/output/terraform-output.json 2>/dev/null; then
            echo "ERROR: Terraform output file is not valid JSON. Attempting direct extraction..."
            
            # Create a new clean file using grep to find the values
            echo "Creating clean JSON with extracted values..."
            echo "{" > kubernetes/output/terraform-output-clean.json
            
            # Extract spaces_region
            REGION_LINE=$(grep -A 3 "spaces_region" kubernetes/output/terraform-output.json | grep "value" | head -1)
            if [[ $REGION_LINE =~ \"value\":[[:space:]]*\"([^\"]+)\" ]]; then
              REGION="${BASH_REMATCH[1]}"
              echo "  \"spaces_region\": { \"value\": \"$REGION\" }," >> kubernetes/output/terraform-output-clean.json
            else
              echo "ERROR: Could not extract spaces_region value"
              exit 1
            fi
            
            # Extract spaces_bucket_name
            BUCKET_LINE=$(grep -A 3 "spaces_bucket_name" kubernetes/output/terraform-output.json | grep "value" | head -1)
            if [[ $BUCKET_LINE =~ \"value\":[[:space:]]*\"([^\"]+)\" ]]; then
              BUCKET="${BASH_REMATCH[1]}"
              echo "  \"spaces_bucket_name\": { \"value\": \"$BUCKET\" }," >> kubernetes/output/terraform-output-clean.json
            else
              echo "ERROR: Could not extract spaces_bucket_name value"
              exit 1
            fi
            
            # Extract dns_configuration
            DNS_LINE=$(grep -A 3 "dns_configuration" kubernetes/output/terraform-output.json | grep "value" | head -1)
            if [[ $DNS_LINE =~ \"value\":[[:space:]]*\"([^\"]+)\" ]]; then
              DNS="${BASH_REMATCH[1]}"
              echo "  \"dns_configuration\": { \"value\": \"$DNS\" }" >> kubernetes/output/terraform-output-clean.json
            else
              echo "No dns_configuration found, adding empty value"
              echo "  \"dns_configuration\": { \"value\": \"\" }" >> kubernetes/output/terraform-output-clean.json
            fi
            
            echo "}" >> kubernetes/output/terraform-output-clean.json
            
            # Replace the original file with the clean one
            mv kubernetes/output/terraform-output-clean.json kubernetes/output/terraform-output.json
            
            echo "Clean JSON file created:"
            cat kubernetes/output/terraform-output.json
          fi
          
          # Extract required values, fail if any are missing
          echo "Extracting values..."
          
          # Extract each value individually with detailed error checking
          DO_SPACES_REGION=$(jq -r '.spaces_region.value // empty' kubernetes/output/terraform-output.json)
          echo "Extracted DO_SPACES_REGION: '$DO_SPACES_REGION'"
          
          DO_SPACES_NAME=$(jq -r '.spaces_bucket_name.value // empty' kubernetes/output/terraform-output.json)
          echo "Extracted DO_SPACES_NAME: '$DO_SPACES_NAME'"
          
          DNS_CONFIG=$(jq -r '.dns_configuration.value // empty' kubernetes/output/terraform-output.json)
          echo "Extracted DNS_CONFIG: '$DNS_CONFIG'"
          
          # Fail if critical values are missing
          if [ -z "$DO_SPACES_REGION" ]; then
            echo "ERROR: spaces_region.value not found or empty in Terraform output"
            exit 1
          fi
          
          if [ -z "$DO_SPACES_NAME" ]; then
            echo "ERROR: spaces_bucket_name.value not found or empty in Terraform output"
            exit 1
          fi
          
          # Set environment variables
          echo "DO_SPACES_REGION=$DO_SPACES_REGION" >> $GITHUB_ENV
          echo "DO_SPACES_NAME=$DO_SPACES_NAME" >> $GITHUB_ENV
          echo "BACKEND_STORE_URI=file:///mlflow-db/mlflow.db" >> $GITHUB_ENV
          echo "DOCKER_REGISTRY=${DOCKER_REGISTRY}" >> $GITHUB_ENV
          echo "IMAGE_TAG=${{ github.sha }}" >> $GITHUB_ENV
          echo "APP_DOMAIN=${{ secrets.APP_DOMAIN }}" >> $GITHUB_ENV
          echo "MLFLOW_DOMAIN=${{ secrets.MLFLOW_DOMAIN }}" >> $GITHUB_ENV
          echo "EMAIL_FOR_SSL=${{ secrets.EMAIL_FOR_SSL || 'admin@example.com' }}" >> $GITHUB_ENV
          echo "UNSPLASH_API_KEY_BASE64=$(echo -n '${{ secrets.UNSPLASH_API_KEY || '' }}' | base64)" >> $GITHUB_ENV
          echo "DO_SPACES_ACCESS_KEY_BASE64=$(echo -n '${{ secrets.DO_SPACES_ACCESS_KEY }}' | base64)" >> $GITHUB_ENV
          echo "DO_SPACES_SECRET_KEY_BASE64=$(echo -n '${{ secrets.DO_SPACES_SECRET_KEY }}' | base64)" >> $GITHUB_ENV
          
          # Set DNS configuration 
          if [ -z "$DNS_CONFIG" ]; then
            echo "WARNING: dns_configuration.value not found or empty in Terraform output"
            echo "DNS_CONFIG=Missing in Terraform output" >> $GITHUB_ENV
          else
            echo "DNS_CONFIG=$DNS_CONFIG" >> $GITHUB_ENV
          fi

      - name: Display Environment Variables
        run: |
          echo "DO_SPACES_REGION: $DO_SPACES_REGION"
          echo "DO_SPACES_NAME: $DO_SPACES_NAME"
          echo "BACKEND_STORE_URI: $BACKEND_STORE_URI"
          echo "S3 ENDPOINT would be: https://$DO_SPACES_REGION.digitaloceanspaces.com"
          echo "DNS Configuration: $DNS_CONFIG"

      - name: Apply Kubernetes Manifests - Cert Manager
        run: |
          export KUBECONFIG=${{ github.workspace }}/.kube/kubeconfig.yaml
          
          # Apply cert-manager issuer
          envsubst < kubernetes/cert-manager/issuer.yaml | kubectl apply -f -

      - name: Get Load Balancer IP and Update DNS
        run: |
          export KUBECONFIG=${{ github.workspace }}/.kube/kubeconfig.yaml
          
          # Wait for NGINX Ingress controller service to get an external IP
          echo "Waiting for NGINX Ingress controller to get an external IP..."
          
          EXTERNAL_IP=""
          for i in {1..30}; do
            EXTERNAL_IP=$(kubectl get svc -n ingress-nginx nginx-ingress-ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
            
            if [ -n "$EXTERNAL_IP" ]; then
              echo "Load balancer has received IP: $EXTERNAL_IP"
              break
            fi
            
            echo "Waiting for load balancer external IP (attempt $i/30)..."
            sleep 10
          done
          
          if [ -z "$EXTERNAL_IP" ]; then
            echo "WARNING: Load balancer did not receive an external IP within timeout."
            echo "DNS records will need to be updated manually."
            exit 0
          fi
          
          echo "Load balancer IP: $EXTERNAL_IP"
          
          # Save the load balancer IP for future use
          echo "LOAD_BALANCER_IP=$EXTERNAL_IP" >> $GITHUB_ENV
          
          # For next Terraform runs, update DNS directly
          echo "For future Terraform runs, set load_balancer_ip=$EXTERNAL_IP"
          
          # Update DNS records using DigitalOcean API if use_do_dns is enabled
          if [[ "${{ secrets.USE_DO_DNS }}" == "true" ]]; then
            echo "Updating DNS records to point to $EXTERNAL_IP..."
            
            # Get domain IDs
            if [[ -n "${{ secrets.APP_DOMAIN }}" ]]; then
              echo "Updating ${{ secrets.APP_DOMAIN }} DNS record..."
              
              # Use the DO API to get record ID and update it
              RECORDS=$(curl -s -X GET \
                -H "Content-Type: application/json" \
                -H "Authorization: Bearer ${{ secrets.DO_TOKEN }}" \
                "https://api.digitalocean.com/v2/domains/${{ secrets.APP_DOMAIN }}/records")
              
              RECORD_ID=$(echo $RECORDS | jq -r '.domain_records[] | select(.type=="A" and .name=="@") | .id')
              
              if [[ -n "$RECORD_ID" ]]; then
                curl -s -X PUT \
                  -H "Content-Type: application/json" \
                  -H "Authorization: Bearer ${{ secrets.DO_TOKEN }}" \
                  -d "{\"data\":\"$EXTERNAL_IP\"}" \
                  "https://api.digitalocean.com/v2/domains/${{ secrets.APP_DOMAIN }}/records/$RECORD_ID"
                
                echo "Updated ${{ secrets.APP_DOMAIN }} DNS record to point to $EXTERNAL_IP"
              fi
            fi
            
            if [[ -n "${{ secrets.MLFLOW_DOMAIN }}" ]]; then
              echo "Updating ${{ secrets.MLFLOW_DOMAIN }} DNS record..."
              
              # Use the DO API to get record ID and update it
              RECORDS=$(curl -s -X GET \
                -H "Content-Type: application/json" \
                -H "Authorization: Bearer ${{ secrets.DO_TOKEN }}" \
                "https://api.digitalocean.com/v2/domains/${{ secrets.MLFLOW_DOMAIN }}/records")
              
              RECORD_ID=$(echo $RECORDS | jq -r '.domain_records[] | select(.type=="A" and .name=="@") | .id')
              
              if [[ -n "$RECORD_ID" ]]; then
                curl -s -X PUT \
                  -H "Content-Type: application/json" \
                  -H "Authorization: Bearer ${{ secrets.DO_TOKEN }}" \
                  -d "{\"data\":\"$EXTERNAL_IP\"}" \
                  "https://api.digitalocean.com/v2/domains/${{ secrets.MLFLOW_DOMAIN }}/records/$RECORD_ID"
                
                echo "Updated ${{ secrets.MLFLOW_DOMAIN }} DNS record to point to $EXTERNAL_IP"
              fi
            fi
          fi
          
      - name: Apply Kubernetes Manifests - MLflow
        run: |
          # Check if MLflow should be deployed
          if [[ "${{ secrets.DEPLOY_MLFLOW }}" == "true" ]]; then
            echo "Deploying MLflow as specified by DEPLOY_MLFLOW=true"
            export KUBECONFIG=${{ github.workspace }}/.kube/kubeconfig.yaml
            
            # Apply MLflow manifests
            envsubst < kubernetes/mlflow/deployment.yaml | kubectl apply -f -
            
            # Wait for MLflow PVC to be bound (give it up to 2 minutes)
            echo "Waiting for MLflow PVC to be provisioned..."
            kubectl wait --for=condition=Ready pvc/mlflow-database -n mlflow --timeout=120s || true
            
            # Force rollout of MLflow deployment to apply changes
            kubectl rollout restart deployment/mlflow -n mlflow
            
            # Wait for initial pod creation but don't fail pipeline if it's not ready yet
            echo "Waiting for initial MLflow pod creation..."
            kubectl rollout status deployment/mlflow -n mlflow --timeout=30s || true
            
            echo "MLflow deployment complete"
          else
            echo "MLflow deployment skipped (DEPLOY_MLFLOW=false or not set)"
            
            # Optionally, clean up MLflow resources if they exist
            export KUBECONFIG=${{ github.workspace }}/.kube/kubeconfig.yaml
            echo "Removing any existing MLflow deployment..."
            
            # Delete MLflow ingress
            kubectl delete ingress -n mlflow mlflow --ignore-not-found=true
            
            # Delete MLflow service
            kubectl delete service -n mlflow mlflow --ignore-not-found=true
            
            # Delete MLflow deployment
            kubectl delete deployment -n mlflow mlflow --ignore-not-found=true
            
            echo "MLflow resources have been removed (if they existed)"
          fi

      - name: Apply Kubernetes Manifests - Web App
        run: |
          export KUBECONFIG=${{ github.workspace }}/.kube/kubeconfig.yaml
          
          # Apply namespace first
          envsubst < kubernetes/web-app/namespace.yaml | kubectl apply -f -
          
          # Apply storage resources
          envsubst < kubernetes/web-app/storage.yaml | kubectl apply -f -
          
          # Apply secrets and configmaps
          envsubst < kubernetes/web-app/spaces-secret.yaml | kubectl apply -f -
          
          # Apply Web App manifests
          envsubst < kubernetes/web-app/deployment.yaml | kubectl apply -f -
          
          # Force rollout of web app deployment to apply changes
          kubectl rollout restart deployment/monet-web-app -n monet-app
          
          # Wait for initial pod creation but don't fail pipeline if it's not ready yet
          echo "Waiting for initial web app pod creation..."
          kubectl rollout status deployment/monet-web-app -n monet-app --timeout=30s || true

      - name: Upload Model to S3
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.DO_SPACES_ACCESS_KEY }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.DO_SPACES_SECRET_KEY }}
          AWS_REGION: ${{ secrets.DO_SPACES_REGION }}
          S3_ENDPOINT: "https://${{ secrets.DO_SPACES_REGION }}.digitaloceanspaces.com"
          BUCKET_NAME: ${{ secrets.DO_SPACES_NAME }}
        run: |
          pip install boto3 mlflow
          
          echo "Using S3 endpoint: $S3_ENDPOINT"
          echo "Using bucket name: $BUCKET_NAME"
          
          # Use the model promotion script to upload and mark as production
          python scripts/promote_model.py photo2monet_cyclegan_mark4.pt \
            --bucket $BUCKET_NAME \
            --version "$(date +%Y%m%d%H%M%S)" \
            --model-name "monet-style-transfer"

      - name: Wait and Verify Deployment
        timeout-minutes: 15
        run: |
          echo "Waiting for services to initialize..."
          sleep 60
          
          echo "Installing required packages for verification..."
          pip install requests urllib3
          
          echo "Running deployment verification..."
          export KUBECONFIG=${{ github.workspace }}/.kube/kubeconfig.yaml
          
          # Determine namespaces to verify
          NAMESPACES="monet-app"
          if [[ "${{ secrets.DEPLOY_MLFLOW }}" == "true" ]]; then
            NAMESPACES="$NAMESPACES,mlflow"
            echo "Verifying both monet-app and mlflow namespaces"
          else
            echo "Only verifying monet-app namespace (MLflow not deployed)"
          fi
          
          python scripts/verify_deployment.py --timeout 600 --skip-wait --namespaces $NAMESPACES
          
          echo "Verification complete!"
          
          echo "You can access the application at:"
          echo "- Monet App: https://${{ env.APP_DOMAIN }}"
          if [[ "${{ secrets.DEPLOY_MLFLOW }}" == "true" ]]; then
            echo "- MLflow: https://${{ env.MLFLOW_DOMAIN }}"
          fi 